[{"title":"thoughts","date":"2017-12-01T13:33:55.000Z","path":"2017/12/01/thoughts/","text":"","tags":[]},{"title":"记一次XCode项目工程文件冲突","date":"2017-05-23T02:31:00.000Z","path":"2017/05/23/记一次XCode项目工程文件冲突/","text":"XCode的项目工程文件.pbxproj的节点排列没有固定次序并且UUID在不同的开发小伙伴的电脑上也会不一样，所以当多人同时修改项目工程文件时，必然会造成冲突，如果强制pull下来，则会导致工程打不开的问题，扎心了老铁。。。 解决方案： 目前我们开发团队初期人数只有三个，所以我们目前采取的方法是只要有人修改过工程文件，就立马commit，然后再群里吼一下，呼叫大家进行更新。。。简单粗暴有木有 后期开发团队发展到两位数的话，这种方式的沟通成本太高，工作效率太低，所以祭出大杀器xUnique先放个链接，后面继续研究。。。 xUnique都做了什么？ 替换所有UUID为项目内永久不变的MD5 digest 删除所有多余的节点（一般是合并的时候疏忽导致的） 用Python重写了我修改过的的sort-Xcode-project-file的排序功能，修改版相较原版增加了以下功能： 对PBXFileReference和PBXBuildFile区块的排序 使用脚本后如果内容没有变化不会生成新文件，避免一次不必要的commit ​","tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"localhost:4000/tags/iOS开发/"}]},{"title":"ios中UIPickerView和UITableView的联动","date":"2017-05-22T08:03:32.000Z","path":"2017/05/22/ios中UIPickerView和UITableView的联动/","text":"“爱呀”校园项目难点之pickerview与tableview的联动 目标效果 ​ 我的思路 左边使用UIPickerView来实现，右边使用含有7个section的tableview实现。Here Comes 我的心路历程… &lt;思路一&gt; 当用户点击左侧pickerVIew的某一天时，在响应点击的代理方法 1234- (void)pickerView:(UIPickerView *)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component&#123; [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;ScrollToHeader&quot; object:[NSNumber numberWithLong:row]];&#125; ​ 里面，给右侧列表发送通知，右侧列表接收到通知后调用方法： 1[self.tableView scrollToRowAtIndexPath:[NSIndexPath indexPathForRow:0 inSection:[[noti object] intValue]] atScrollPosition:UITableViewScrollPositionTop animated:YES]; 将相应的section滚动到top位置。 右边到左侧的同步则是利用每一个section的header即将display的时候： 1- (void)tableView:(UITableView *)tableView willDisplayHeaderView:(UIView *)view forSection:(NSInteger)section &#123;&#125; 中给左侧picker发送通知，使其调用 1[self.dayPicker selectRow:[(NSNumber*)[noti object] intValue] inComponent:0 animated:YES]; 方法进行同步。 该方法存在的问题是：当用户选择左侧的picker时，右边列表滚动过程中会多次调用方法对左侧发送通知，导致其选中的picker会发生偏移,此方法GG &lt;思路二&gt; 考虑第一种思路下，如果使用当前列表屏幕中的cells的indexpath,找最小的indexpath.section，它就是左侧应当显示的哪一天。所以现在的逻辑就是tableview的属性indexPathsForVisibleRows发生变化的时候给左侧发通知。考虑使用KVO模式，即self注册为自己tableview的观察者，接收到变化时候给左侧发通知。 此方法存在的问题是，KVO对数组等集合性质的属性是无效的，因为引用值并不会发生变化，所以此路不通。 &lt;思路三&gt; 左侧的picker调用selectRow:inComponent:animated:方法的情况应当是，当右侧有新的header将要出现(will display)或者有旧的header将要消失(did end display)时，判断当前可见的cells中的indexpath的最小section值。所以最终我的思路是：picker向table发通知的方式调用table的scrollToRowAtIndexPath:atScrollPosition:animated方法进行滚动，而table向picker则是在WillDisplayHeaderView和didEndDisplayingHeaderView方法中根据tableview的visibleIndexPaths数组寻找当前屏幕中最小的section，如果该最小的section和该TableViewController的属性currentSection不一致，则向picker发送通知，调用其selectRow方法进行滚动。","tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"localhost:4000/tags/iOS开发/"}]},{"title":"OC的元类与父类以及isa指针关系图","date":"2017-03-18T14:23:26.000Z","path":"2017/03/18/OC的元类与父类以及isa指针关系图/","text":"在Objective-C中，metaclass代表类对象（类也是一种对象，因为含有Class isa指针）的类。 所有的元类都使用根元类（继承体系中处于顶端的类的元类）作为他们的类。这就意味着所有NSObject的子类（大多数类）的元类都会以NSObject的元类作为他们的类 根据这个规则，所有的元类使用根元类作为他们的类，根元类的元类则就是它自己。也就是说基类的元类的isa指针指向他自己。 引用自—Objective-C 中的元类（meta class）是什么？","tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"localhost:4000/tags/iOS开发/"}]},{"title":"ios的Frame与Bounds","date":"2017-02-24T12:30:50.000Z","path":"2017/02/24/ios的Frame与Bounds/","text":"理解ios view的frame与bounds而者都是CGRect的，都是含有origin 和 size两个结构体属性 不同之处：frame是相对于父View而言的，而bounds则相对于自己的坐标系，所以bounds的origin一定是（0，0）。","tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"localhost:4000/tags/iOS开发/"}]},{"title":"git使用--点滴记录","date":"2017-02-13T04:52:20.000Z","path":"2017/02/13/git使用-点滴记录/","text":"Git多人协作一般流程 首先，可以试图用git push origin branch-name推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！ 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream branch-name origin/branch-name。 Git教程—廖雪峰 Git版本回退 git log 可以查看所有的commit历史，git reflog可以查看命令历史，两者搭配使用可以得到你想要回退到的commit之后的SHA1值（类似于该次commit的ID）。 git reset —hard commit_SHA1，该命令表示回退到ID为commit_SHA1的那次commit之后的状态。 –soft Does not touch the index file or the working tree at all (but resets the head to , just like all modes do). This leaves all your changed files “Changes to be committed”, as git status would put it. –mixed Resets the index but not the working tree (i.e., the changed files are preserved but not marked for commit) and reports what has not been updated. This is the default action.If -N is specified, removed paths are marked as intent-to-add (see git-add[1]). –hard Resets the index and working tree. Any changes to tracked files in the working tree since are discarded. –merge Resets the index and updates the files in the working tree that are different between and HEAD, but keeps those which are different between the index and working tree (i.e. which have changes which have not been added). If a file that is different between and the index has unstaged changes, reset is aborted.In other words, –merge does something like a git read-tree -u -m , but carries forward unmerged index entries. –keep Resets index entries and updates files in the working tree that are different between and HEAD. If a file that is different between and HEAD has local changes, reset is aborted. 如果只是想撤回某次commit，考虑使用 git revert。","tags":[{"name":"Git","slug":"Git","permalink":"localhost:4000/tags/Git/"}]},{"title":"iOS多线程","date":"2017-02-04T11:45:39.000Z","path":"2017/02/04/iOS多线程/","text":"ios多线程四种方法 Pthreads 支持多系统的通用多线程API NSThread ios将POSIX封装好的面相对象的多线程类 GCD Grand Central Dispatch 大法好 NSOperation &amp; NSOperationQueue ios对GCD的封装 区别直接上图 GCD GCD简介 GCD 全称是Grand Central Dispatch，可译为“超级厉害的中枢调度器”，GCD 是苹果公司为多核的并行运算提出的解决方案， GCD会自动利用更多的 CPU 内核（比如双核、四核）来开启线程执行任务，GCD 会自动管理线程的生命周期（创建线程、调度任务、销毁线程），不需要我们程序员手动管理内存。 使用 获取主队列 主队列是全局串行队列，用于控制UI。 1dispatch_queue_t main = dispatch_get_main_queue(); 获取全局并行队列 系统提供的全局并发队列，一般耗时操作放在全局并行队列执行。 1dispatch_queue_t global = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); 自己创建串行和并行队列 1234//串行队列dispatch_queue_t queue1 = dispatch_queue_create(&quot;JackPanda.serial&quot;, DISPATCH_QUEUE_SERIAL);//并行队列dispatch_queue_t queue2 = dispatch_queue_create(&quot;JackPanda.concurrence&quot;, DISPATCH_QUEUE_CONCURRENCE); 创建同步和异步任务 1234567891011121314//同步任务dispatch_sync(main, ^&#123; NSLog(@&quot;同步任务 在 串行队列 中执行&quot;)；&#125;);dispatch_sync(global, ^&#123; NSLog(@&quot;同步任务 在 并行队列 中执行&quot;)；&#125;);//异步任务dispatch_async(queue1, ^&#123; NSLog(@&quot;异步任务 在 串行队列 中执行&quot;)；&#125;);dispatch_async(queue2, ^&#123; NSLog(@&quot;异步任务 在 并行行队列 中执行&quot;)；&#125;); 其实多线程的重点就在同步异步任务—dispatch_sync和dispatch_async，串行和并行都是FIFO取出来，也都是分配cpu时间片，只不过串行队列的任务不会出现交叉使用时间片，一定是按照先后顺序接受分配cpu。 从其它线程回到主线程 123dispatch_async(dispatch_get_main_queue(), ^&#123; //self.label.text = xxx;&#125;); ​ Tips 其实并不是绝对的同步任务就一定在当前线程，异步任务就一定会在新开的线程执行。同步(sync)任务当从其它线程向主线程派发时，就会在主线程执行，当异步(async)任务从主线程向主线程派发时，也会在主线程执行，并不会新开线程。同步和异步主要区别是：是否会阻塞当前线程。 无论串行还是并发队列,任务启动顺序都是按照 FIFO 的,只是并发队列允许同一时间有多个任务执行都在执行. NSOperation &amp;NSOperationQueue NSOperation是抽象类，一般使用NSInvokeOperation和NSBlockOperation或者它们的子类创建任务， 步骤简述 先将需要执行的操作封装到一个NSOperation的子类对象中 然后将NSOperation对象添加到NSOperationQueue中 系统会自动将NSOperationQueue中的NSOperation取出来 将取出的NSOperation封装的操作放到一条新线程中执行 未完待续。。。","tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"localhost:4000/tags/iOS开发/"}]},{"title":"ios的UINavigationController","date":"2017-02-02T15:13:41.000Z","path":"2017/02/02/ios的UINavigationController/","text":"UINavigationController的结构层次 一张图说明一切 通俗地说就是，uinavigationController是个容器，里面可以装很多uiviewController。装这么多uiviewController让用户怎么控制它们呢，总得有个工具吧。这个工具就是uinavigationBar。一个容器就这么一个bar，相当于控制台吧。但是，管理那么多uiviewController，控制台上得按钮啊、标题啊，都千篇一律是不是看起来太无聊了。为了解决这个问题，uinavigationController为每个uiviewController生成一个uinavigationBarItem，通过这个uinavigationBarItem可以改变控制台“上面”得按钮和标题。如果你不自定义uinavigationBarItem，uinavigationController会使用默认的。 ​ 图片和总结来源于博客地址 源码分析 UINavigationController 它是UIViewController的子类，它管理着一个总的UINavigationBar、一个总的UIToolBar和UIViewController的栈容器。 1234567891011//AppDelegate.m 初始化RootViewController *rootViewController = [[RootViewController alloc] init];UINavigationController *navi = [[UINavigationController alloc] initWithRootViewController:rootViewController];self.window.rootViewController = navi;//AViewController 入栈AViewController* aVC = [[AViewController alloc] init];[self.navigationController pushViewController:aVC animated:NO];//BViewController 出栈[self.navigationController popViewControllerAnimated:YES]; UINavigationBar UINavigationBar只有一个，它永远只属于UINavigationController，是所有UIViewController公用的。所以，当你修改了UINavigationBar的背景图片或者颜色时，相当于修改了所有UIViewController的NavigationBar的背景图片或颜色。 所以如果有在Storyboard使用NavigationBar控件，一定在注意该ViewController是否是出于NavigationController的视图栈中。如果是，则要调用 1self.navigationController.navigationBarHidden = YES; 将其隐藏掉，以显示xib或者storyboard的navigationbar控件。 UINavigationItem UINavigationController会为每一个入栈的UIViewController生成一个UINavigationItem. UIViewController通过修改UINavigationItem可以控制UINavigationBar上的按钮和标题等。 UIViewController 每一个视图栈中的ViewController都可以访问navigationController和navigationItem属性设置其导航栏。","tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"localhost:4000/tags/iOS开发/"}]},{"title":"ios不同屏幕分辨率下的设计规范","date":"2017-02-01T10:14:24.000Z","path":"2017/02/01/ios不同屏幕分辨率下的设计规范/","text":"iOS自诞生以来的各种尺寸屏幕的分辨率一览 ​ ​ 可以按照ppi将所有屏幕分辨率分成@1x-163ppi，@2x—326ppi和@3x—401ppi一共三种。 ​ iOS开发的基本单位是pt(point)，在非Retina屏幕下，@1x的屏幕对应的1pt=1px，@2x和@3x下的一个pt则对应2px与3px。现在大多都是Retina屏幕，所以，@1x的屏幕对应的1pt=2px，@2x和@3x下的一个pt则对应4px与6px。 在使用xcode的storyboard进行UI绘制时，所有的数字单位是pt，而且是@1xppi比例下的1pt=2px，尽管像下图所示的storyboard可以选择以iPhone5se，iPhone6，iPhone7plus等各种不同的设备去查看app的显示效果，但是实际设计时，仍旧按照@1x下进行，在app运行时autolayout能自动进行绘制布局。 ​ ​ 所以iOS程序员在按照设计图进行设计时候，应当和美工沟通清楚该设计图是基于多少ppi的，这样才能确定1pt等于几个px（一点有几个像素），因为只说分辨率不讲ppi的手机厂商都是耍流氓。 ​ 下图是iOS不同分辨率下的导航栏等的设计规范。 在美工切图的时候，注意按照@1x，@2和@3x的大小进行设计，现在@1x的手机几乎已经灭绝，所以只切@2x和@3x的即可。","tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"localhost:4000/tags/iOS开发/"}]},{"title":"LeetCode-006-ZigZagConversion","date":"2017-01-13T01:58:33.000Z","path":"2017/01/13/LeetCode-006-ZigZagConversion/","text":"leetCode-006-ZigZagConversion 题目描述 将给定的字符串以“之”字的形状排列，然后一行一行地读取得到新的字符串输出。例如”PAYPALISHIRING”的之字形排列如下： | P | | A | | H | | N || :—: | :—: | :—: | :—: | :—: | :—: | :—: || A | P | L | S | I | I | G || Y | | I | | R | | |输出为”PAHNAPLSIIGYIR” 。现要求给出nRows，表示之字形排列时的行数（上面的nRows=3），输出转换后的字符串。 LC-006 ​ 题目分析 之字形排列过程是由许多的下降（第一列PAY）、斜上升（YPA）组成的，建立一个有nRows个元素的StringBuilder，在循环遍历的过程中不断地在相应位置进行字符串拼接。 Java源码 123456789101112131415161718192021222324252627282930public class Main &#123; public static String convert(String s, int nRows) &#123; char[] c = s.toCharArray(); int len = c.length; StringBuilder[] sb = new StringBuilder[nRows]; for (int i = 0; i &lt; sb.length; i++) sb[i] = new StringBuilder(); int i = 0; while (i &lt; len) &#123; for(int j = 0; j &lt; nRows &amp;&amp; i &lt; len; j++) &#123; sb[j].append(c[i]); i++; &#125; for(int j = nRows - 2; j &gt;= 1 &amp;&amp; i &lt; len ; j --) &#123; sb[j].append(c[i]); i++; &#125; &#125; for (int idx = 1; idx &lt; sb.length; idx++) sb[0].append(sb[idx]); return sb[0].toString(); &#125; public static void main(String[] args) &#123; System.out.println(Main.convert(\"PAYPALISHIRING\", 4)); &#125;&#125; stay hungry, stay foolish. –steve jobs.","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"localhost:4000/tags/LeetCode/"}]},{"title":"LeetCode-002-Add-Two-Numbers","date":"2017-01-11T14:41:58.000Z","path":"2017/01/11/LeetCode-002-Add-Two-Numbers/","text":"LeetCode-002 Add Two Numbers 题目描述给定两个非负整数，将其按照个位-&gt;十位-&gt;百位..的逆序形式作为输入，要求输出两个数之和的逆序形式。例如输入为 3-&gt;5-&gt;7和4-&gt;6-&gt;5，输出为7-&gt;1-&gt;3-&gt;1。 LC-002 题目分析 第一反应是转成两个整数在让其相加然后再逆序转回来，但是很明显这样的时间复杂度太高。既然给出了逆序的数，可以想办法直接对其进行加法运算。加法无非就是相应位置上的数字相加然后再加上前一位传过来的进位进行加一操作。 核心技巧：每一位都在重复一个操作——相同位置数字之和对10取余+前一个位置数字之和除以10的结果（0或者1）. Java源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.*;import java.lang.StringBuilder;public class Main &#123; public static ListNode addTwoNumbers(ListNode list1, ListNode list2) &#123; ListNode result = new ListNode(0); ListNode start = result; int sum = 0; while(list1 != null || list2 != null) &#123; sum = sum/10;//精髓在这里。整数位与位之间的加法与进位：利用整数的除法， //不足十的数除以十得到0，下一位进位为0，多于十的数除以十也是得到下一位的进位 if(list1 != null) &#123; sum += list1.val; list1 = list1.next; &#125; if(list2 != null) &#123; sum += list2.val; list2 = list2.next; &#125; result.next = new ListNode(sum % 10); result = result.next; &#125; if(sum/10 == 1) &#123; result.next = new ListNode(1); &#125; return start.next; &#125; public static void main(String[] args) &#123; String input = new String(\"(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)\"); String output = \"\"; String firstList, secondList; String[] splitResult = input.split(\"\\\\+\"); firstList = splitResult[0]; secondList = splitResult[1]; firstList = firstList.replaceAll(\"\\\\(|\\\\)|\\\\-|\\\\&gt;| \", \"\"); secondList = secondList.replaceAll(\"\\\\(|\\\\)|\\\\-|\\\\&gt;| \", \"\"); ListNode list1 = new ListNode(0); ListNode list2 = new ListNode(0); ListNode node1 = list1; ListNode node2 = list2; for(int i = 0; i &lt; firstList.length(); i++) &#123; list1.val = firstList.toCharArray()[i] - '0'; list1.next = (i != firstList.length() - 1)? (new ListNode(0)):null; list1 = list1.next; &#125; list1 = node1; for(int i = 0; i &lt; secondList.length(); i++) &#123; list2.val = secondList.toCharArray()[i] - '0'; list2.next = (i != secondList.length() - 1)? (new ListNode(0)):null; list2 = list2.next; &#125; list2 = node2; ListNode result = Main.addTwoNumbers(list1, list2);// System.out.println(result.val); while(result != null) &#123; if(result.next != null) &#123; output = output + (new Integer(result.val)).toString() + \" -&gt; \"; &#125; else &#123; output = output + (new Integer(result.val)).toString(); &#125; result = result.next; &#125; System.out.println(output); &#125;&#125;class ListNode &#123; int val; ListNode next; public ListNode(int val) &#123; this.val = val; &#125;&#125; stay hungry, stay foolish. –steve jobs.","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"localhost:4000/tags/LeetCode/"}]},{"title":"LeetCode-001-TwoSum","date":"2017-01-09T06:19:17.000Z","path":"2017/01/09/LeetCode-001-TwoSum/","text":"###LeetCode-001 Two Sum 题目描述 给定一个数组nums和一个目标整数target，判断nums中是否含有两个数，他们的数值之和等于target，如果存在则返回这两个数的索引值。 LC-001 题目分析 因为题目中求的是数值的和，而返回的结果是索引值，所以第一感觉是要建立key-value的hashmap，以空间换取时间，时间复杂度为o(n)。 找两数之和为target，反过来就是找对于nums中的第i个数，是否有另外一个nums中的数其值为target - nums[i]。 所以要对nums建立HashMap map，遍历一遍看map.containsKey(target - map.get[i])是否为true。 优化 两个数肯定要一前一后地进入到map中，所以可以在向map中put数据的时候就进行一次判断看map.containsKey(target - map.get[i])是否为true。 Java代码 123456789101112131415161718public class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] result = new int[2]; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for(int i =0; i &lt; nums.length; i++) &#123; if(map.containsKey(target - nums[i])) &#123; result[1] = i; result[0] = map.get(target- nums[i]); return result; &#125; map.put(nums[i], i); &#125; return result; &#125;&#125; ​ stay hungry, stay foolish. –steve jobs.","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"localhost:4000/tags/LeetCode/"}]},{"title":"iOS开发思维导图","date":"2017-01-07T13:28:24.000Z","path":"2017/01/07/iOS思维导图-0/","text":"iOS开发思维导图之简略版 ​ iOS思维导图之完整版 stay hungry, stay foolish. —steve jobs.","tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"localhost:4000/tags/iOS开发/"}]}]